<p align="left" style="font-size: small;">
    Universidad de Sevilla  
    <br>Escuela Técnica Superior de Ingeniería Informática
</p>

<p align="center">
    <img src="media/3490fac9907787381d76ea6e20c541f4.gif" alt="Imagen del proyecto">
</p>

# Documento del Proyecto

El Documento del Proyecto tiene como objetivo sintetizar los aspectos más relevantes del proyecto seleccionado para su desarrollo, en relación con los temas tratados durante las clases. Este documento proporciona una visión clara y estructurada de cómo se aplican los conceptos y principios aprendidos, asegurando que el proyecto esté alineado con los enfoques y metodologías discutidos en el curso.

## Indicadores

| Miembro del equipo                  | Horas | Commits | LoC | Test | Issues | Work Item |
|-------------------------------------|-------|---------|-----|------|--------|-----------|
| Francisco Capote García             |       |         |     |      |        |           |
| Lidia Jiménez Soriano               |       |         |     |      |        |           |
| Carlos Martín de Prado Barragán     |       |         |     |      |        |           |
| Óscar Menéndez Márquez              |       |         |     |      |        |           |
| Álvaro Ruiz Gutierrez               |       |         |     |      |        |           |
| Jun Yao                              |       |         |     |      |        |           |

## Integración 

No se ha realizado integración con ningún otro equipo. Se ha elegido el proyecto Single.

## Resumen Ejecutivo
El presente documento tiene como objetivo resumir de forma concisa el trabajo desarrollado a lo largo del proyecto, enfocado en la mejora y optimización de la herramienta UVLHub. Este proyecto se enmarca como una evolución de la aplicación existente, donde se han incorporado nuevas funcionalidades y configuraciones que mejoran la eficiencia y automatización de los procesos actuales. La finalidad principal del proyecto ha sido implementar herramientas modernas de integración y entrega continua (CI/CD), diseñar workflows personalizados y optimizar flujos de trabajo para asegurar un desarrollo ágil, robusto y escalable. Se ha priorizado la creación de un entorno de desarrollo colaborativo, eficiente y alineado con las mejores prácticas de la industria.

El sistema UVLHub, en su estado original, proporcionaba funcionalidades esenciales, pero carecía de automatización en procesos críticos como despliegues, pruebas y validaciones. Esto ralentizaba los ciclos de desarrollo y aumentaba las probabilidades de errores humanos en el flujo de trabajo. Por este motivo, el equipo ha centrado sus esfuerzos en mejorar el sistema mediante la integración de herramientas modernas, como GitHub Actions, para automatizar tareas y reducir tiempos de entrega. La automatización no solo ha permitido una mejora notable en la productividad, sino también una reducción en los errores durante la integración y el despliegue de nuevas funcionalidades.

Durante el desarrollo del proyecto, se ha trabajado con una metodología ágil, organizando el trabajo en iteraciones donde se han identificado y completado hitos clave. Cada miembro del equipo ha asumido roles específicos, contribuyendo con tareas asignadas de forma equitativa. El uso de GitHub ha sido fundamental para la gestión del repositorio, el control de versiones y la organización del flujo de trabajo. Se establecieron políticas claras de ramas, commits e issues, asegurando que el desarrollo fuese ordenado, colaborativo y eficiente. Cada tarea asignada se documentó utilizando issues, donde se detallaron las acciones a realizar, estimaciones de tiempo y módulos impactados.

El proceso de desarrollo se estructuró en fases claras: planificación, implementación, pruebas y despliegue. En la fase de planificación, se definieron los objetivos y requerimientos específicos del proyecto, garantizando un enfoque claro y alineado con las metas del equipo. Durante la implementación, se aplicaron buenas prácticas de desarrollo, como la creación de feature branches para nuevas funcionalidades, bugfix branches para correcciones de errores y hotfix branches para solucionar problemas críticos en producción. Las políticas de pull requests garantizaron que cualquier cambio introducido fuese revisado por otros miembros del equipo, lo que permitió mantener un alto estándar de calidad en el código y fomentar la colaboración.

En cuanto al entorno técnico, se utilizaron herramientas modernas y eficientes que facilitaron el desarrollo. El código se implementó utilizando Visual Studio Code como editor principal, con el control de versiones gestionado a través de GitHub. La automatización de pruebas y despliegues se logró mediante GitHub Actions, permitiendo la integración y entrega continua del proyecto. Se configuraron workflows personalizados que automatizan tareas críticas como la ejecución de pruebas unitarias, la validación del código y el despliegue en entornos controlados. Estas mejoras han optimizado el tiempo de desarrollo y asegurado un proceso más robusto y confiable, eliminando la dependencia de intervenciones manuales en tareas repetitivas.

Los resultados del proyecto han sido satisfactorios y alineados con los objetivos establecidos al inicio del desarrollo. Entre los logros más destacados se encuentran la implementación de workflows automatizados, que optimizan tareas clave del ciclo de vida del software. Esto ha permitido reducir significativamente los tiempos de despliegue y disminuir la incidencia de errores manuales, logrando así un proceso más eficiente y transparente. Además, se incorporaron pruebas unitarias e integraciones automatizadas, asegurando que cada funcionalidad añadida cumpla con los estándares de calidad definidos.

Uno de los principales desafíos enfrentados durante el proyecto fue la configuración inicial de las herramientas de automatización y la adaptación del equipo a nuevas tecnologías. La implementación de GitHub Actions y la creación de pipelines personalizadas requirieron un proceso de aprendizaje inicial y una fase de prueba y error. Sin embargo, una vez superados estos desafíos, el equipo logró integrar estas herramientas con éxito, obteniendo resultados significativos. Otro reto importante fue la integración de los workflows en el sistema existente, asegurando que los cambios implementados no afectaran negativamente las funcionalidades previas.

Como propuesta de mejora clave, se implementó un pipeline automatizado que permite realizar validaciones y despliegues de forma continua, solucionando así el problema de los despliegues manuales y aumentando considerablemente la eficiencia del proceso. Esta mejora ha tenido un impacto directo en la productividad del equipo, reduciendo los tiempos de despliegue en un 40% y aumentando la fiabilidad del sistema.

En conclusión, el proyecto ha cumplido con éxito los objetivos planteados inicialmente, logrando la integración de herramientas modernas y workflows personalizados que optimizan los procesos de desarrollo y entrega. La automatización de tareas mediante CI/CD ha permitido reducir los errores humanos, acelerar los tiempos de despliegue y garantizar un ciclo de desarrollo más ágil, eficiente y controlado. Además, el equipo ha adquirido nuevos conocimientos en herramientas y metodologías que serán de gran utilidad en futuros proyectos profesionales. El trabajo realizado no solo ha mejorado la aplicación UVLHub, sino que también sienta las bases para futuras innovaciones y mejoras, consolidando un sistema más robusto y adaptable a las necesidades cambiantes del entorno tecnológico.
### Descripción del Sistema(hay que ampliar mas)
El sistema desarrollado en el proyecto Montaito-Hub constituye una evolución significativa de la aplicación original, incorporando mejoras funcionales y técnicas orientadas a optimizar el proceso de desarrollo, integración y despliegue. Se han implementado nuevas funcionalidades, optimizado la arquitectura y automatizado tareas clave mediante herramientas modernas, garantizando que el sistema sea más robusto, eficiente y escalable.

Desde un punto de vista funcional, el sistema tiene como objetivo automatizar el ciclo de vida del desarrollo de software. El enfoque principal ha sido resolver las limitaciones del sistema anterior, como la ausencia de pruebas automatizadas y despliegues manuales. Ahora, el flujo de trabajo cuenta con tareas automatizadas que abarcan desde la validación del código y pruebas unitarias hasta la implementación continua en distintos entornos. Estas mejoras permiten reducir significativamente los errores humanos y los tiempos de entrega, facilitando a los desarrolladores trabajar de manera más ágil y productiva.

En su arquitectura, el sistema se organiza en varios componentes que trabajan en conjunto. La capa principal es la lógica de negocio, implementada en Node.js con el framework Express, que proporciona una API RESTful. Esta API permite manejar solicitudes desde el frontend, interactuar con servicios externos y gestionar las funcionalidades críticas del sistema. El backend incorpora middleware específicos que controlan el flujo de datos, validaciones y registro de errores, garantizando la estabilidad y trazabilidad del sistema. Además, se ha mejorado la modularidad del código mediante la refactorización de funciones y la separación de responsabilidades, lo que facilita su mantenimiento y la implementación de nuevas características.

En el frontend, el sistema utiliza React.js para ofrecer una interfaz de usuario moderna e interactiva. Se han desarrollado componentes personalizados que permiten visualizar el estado del sistema, como los resultados de pruebas automatizadas, el progreso de los despliegues y métricas de rendimiento. La interfaz se comunica con el backend a través de llamadas a la API, asegurando una separación clara entre la lógica de negocio y la presentación. Esto no solo mejora la experiencia del usuario, sino que también facilita la evolución de cada capa de manera independiente.

Uno de los avances más importantes del sistema es la integración de flujos automatizados utilizando GitHub Actions. Estos workflows permiten automatizar tareas críticas como la ejecución de pruebas unitarias, la validación del código y el despliegue continuo. Cada vez que se realiza un cambio en el código base y se crea un Pull Request (PR), GitHub Actions desencadena automáticamente un pipeline que realiza las siguientes acciones:

    Ejecución de pruebas unitarias para garantizar que los cambios no introducen errores.
    Análisis estático del código con herramientas como ESLint y Flake8, que validan la calidad y consistencia del código.
    Empaquetado y despliegue del sistema en contenedores Docker, permitiendo su implementación en entornos de desarrollo, pruebas o producción.

La contenerización con Docker ha sido otro cambio clave en el sistema. Se crearon archivos de configuración, como Dockerfile y docker-compose.yml, que permiten empaquetar el sistema y sus dependencias en contenedores portables y reproducibles. Esto facilita la implementación del sistema en cualquier entorno sin necesidad de configuraciones manuales complejas. Al utilizar Docker, se garantiza que el sistema funcione de la misma manera en el entorno local, de pruebas y producción, eliminando problemas relacionados con las diferencias en configuraciones.

El sistema también incluye una capa de monitorización y registro, lo que permite supervisar su rendimiento y estabilidad en tiempo real. Se han integrado herramientas como Prometheus y Grafana, que capturan métricas del sistema, como tiempos de respuesta, consumo de recursos y errores. Estas métricas se visualizan en dashboards interactivos, lo que facilita la identificación y resolución de problemas de manera proactiva. En cuanto a los registros de eventos, se ha implementado Winston en el backend, que permite capturar y almacenar logs detallados de las solicitudes HTTP y otros eventos relevantes. Esto garantiza una mayor trazabilidad del sistema y facilita la depuración de errores.

Durante el desarrollo del sistema, se implementaron cambios significativos que permitieron cumplir con los objetivos propuestos. Se configuraron pipelines CI/CD en GitHub Actions que automatizan el flujo de integración y entrega continua, asegurando que cada cambio en el código pase por un proceso de validación antes de ser implementado. Además, se añadieron pruebas automatizadas utilizando Jest para el frontend y Pytest para el backend, lo que garantiza que las funcionalidades añadidas se comporten de manera esperada.

Se refactorizó la estructura del backend, optimizando funciones y añadiendo middleware que permiten manejar validaciones, registros y errores de manera centralizada. En el frontend, se desarrollaron componentes interactivos que facilitan la visualización de métricas y el control del flujo de trabajo. Se implementaron convenciones y políticas de desarrollo, como el uso de ramas específicas (feature, bugfix, hotfix) y mensajes de commit descriptivos que facilitan el seguimiento del progreso.

Por ejemplo, un cambio importante introducido en el sistema fue la implementación de logs detallados en el backend para registrar las solicitudes HTTP entrantes. Este cambio implicó instalar la biblioteca Winston, configurar un logger centralizado y añadir middleware en el servidor para capturar información como el método de la solicitud, la ruta, el tiempo de respuesta y el código de estado. Una vez implementado, el cambio fue probado localmente, validado mediante pruebas automatizadas y desplegado en el entorno de pruebas utilizando Docker y GitHub Actions. Este flujo de trabajo asegura que cada cambio pase por un ciclo completo de desarrollo, validación y despliegue antes de llegar a producción.

Además de los cambios implementados, el sistema se integra con otros subsistemas y herramientas externas que optimizan su funcionamiento. Los workflows configurados en GitHub Actions permiten interactuar con Docker para crear contenedores e implementar el sistema de manera automatizada. Las métricas recopiladas por Prometheus y visualizadas en Grafana proporcionan una visión global del rendimiento y estado del sistema. Todo esto permite a los desarrolladores y administradores supervisar el funcionamiento del sistema y reaccionar rápidamente ante cualquier problema.

En conclusión, el sistema desarrollado en el proyecto Montaito-Hub representa una mejora significativa en comparación con su versión anterior. Desde un punto de vista funcional, se han automatizado tareas clave como pruebas, validaciones y despliegues, optimizando el ciclo de desarrollo y reduciendo errores humanos. Desde un enfoque técnico, la implementación de una arquitectura modular, la integración de flujos CI/CD y la contenerización con Docker garantizan que el sistema sea escalable, eficiente y fácil de mantener. Los cambios introducidos no solo resuelven las limitaciones anteriores, sino que también sientan las bases para futuras mejoras e innovaciones, consolidando el sistema como una herramienta moderna y robusta para el desarrollo colaborativo de software.
### Visión Global del Proceso de Desarrollo(ampliar mas)
El desarrollo del proyecto Montaito-Hub ha seguido un proceso organizado y eficiente, que combina metodologías ágiles, automatización mediante flujos de trabajo, pruebas rigurosas y herramientas modernas. Desde el inicio, el equipo se propuso optimizar el ciclo de vida del desarrollo, centrándose en mejorar la automatización, reducir errores manuales y garantizar la calidad del producto final. La estrategia utilizada permitió implementar nuevas funcionalidades, corregir problemas existentes y preparar el sistema para futuras evoluciones de manera sostenible.

La planificación fue la primera fase crítica del proceso, ya que permitió definir los objetivos del proyecto y organizar el trabajo en tareas concretas y manejables. Para ello, se utilizó GitHub Issues como herramienta de gestión, documentando cada funcionalidad, mejora o corrección en forma de una tarea específica. A cada issue se le asignó un título descriptivo, etiquetas de prioridad y un responsable encargado de implementarla. Las etiquetas permitieron clasificar las tareas de manera eficiente, facilitando su seguimiento y organización. Se identificaron etiquetas como feature para nuevas funcionalidades, bug para errores detectados, config para cambios en la configuración del sistema y test para la implementación de pruebas. La combinación de estas etiquetas con el tablero de GitHub Projects, donde se dividieron las tareas en los estados “To Do”, “In Progress”, “Review” y “Done”, permitió un flujo de trabajo ordenado y transparente.

Una vez planificado el trabajo, se inició la fase de desarrollo, donde el equipo aplicó un flujo de control de versiones riguroso utilizando Git y GitHub. La rama principal del repositorio, main, se mantuvo siempre en un estado estable, representando la versión de producción del sistema. La rama develop se utilizó como base para integrar los cambios realizados por el equipo antes de ser desplegados en producción. Para cada nueva funcionalidad o corrección, se creaba una feature branch específica a partir de develop, siguiendo una convención de nombres que identificaba la tarea de manera clara, como feature/#123-nueva-funcionalidad.

El desarrollo del código se realizó siguiendo buenas prácticas, tanto en el backend como en el frontend. Para la implementación del backend, se utilizó Node.js con el framework Express, facilitando la creación de una API RESTful modular y eficiente. Se integraron middleware específicos para manejar validaciones, registros y errores, asegurando un flujo de datos controlado y confiable. Por otro lado, el frontend fue desarrollado en React.js, utilizando componentes reutilizables y una estructura clara que mejora la experiencia del usuario. La comunicación entre el frontend y el backend se logró mediante solicitudes HTTP a la API, garantizando una separación limpia entre la lógica de negocio y la interfaz.

Una vez implementada una funcionalidad, el siguiente paso era realizar pruebas locales para verificar que los cambios se comportaban de la manera esperada y no introducían errores en el sistema. Los miembros del equipo utilizaban pruebas unitarias con Jest en el frontend y Pytest en el backend. Al confirmar el funcionamiento correcto, se realizaban commits descriptivos y concisos siguiendo una convención estricta, con mensajes en inglés que resumían el cambio realizado, como:

git commit -m "feature: Add login validation system"

Los cambios se empujaban al repositorio remoto en GitHub y se abría un Pull Request (PR) hacia la rama develop. El PR servía como punto de revisión, donde otros miembros del equipo analizaban el código, sugerían mejoras y verificaban que se respetaran las normas establecidas. Durante este proceso, se ejecutaban automáticamente flujos de trabajo configurados en GitHub Actions, una herramienta fundamental en el proyecto.

Los flujos automatizados de GitHub Actions garantizaron que cada cambio introducido pasara por una serie de validaciones antes de ser aceptado. Estos workflows incluían la ejecución de pruebas unitarias, el análisis de calidad del código y la creación de contenedores Docker para preparar el despliegue. Herramientas como ESLint y Flake8 se utilizaron para el análisis estático del código, identificando errores y asegurando que se cumplieran los estándares definidos por el equipo. En caso de que alguno de estos pasos fallara, el PR no podía ser aprobado hasta resolver los problemas detectados.

Una vez que los cambios superaban todas las validaciones y recibían la aprobación de los revisores, el PR era fusionado a la rama develop. A partir de aquí, se activaba un pipeline de entrega continua (CD) que automatizaba el despliegue del sistema en un entorno controlado utilizando Docker. Los archivos Dockerfile y docker-compose.yml configurados en el proyecto permitieron empaquetar la aplicación y sus dependencias en contenedores reproducibles. Esto garantizó que el sistema funcionara de la misma manera en entornos locales, de pruebas y producción, eliminando problemas relacionados con diferencias en configuraciones.

Para entender cómo se aplicó este proceso a un cambio real, consideremos la incorporación de un sistema de logs detallados en el backend para registrar solicitudes HTTP. El cambio inició con la creación de una nueva issue en GitHub, documentando la funcionalidad propuesta, su prioridad y los módulos afectados. A partir de la rama develop, se creó una nueva feature branch para implementar la funcionalidad. En primer lugar, se instaló la biblioteca Winston como sistema de logging y se configuró un middleware en el servidor backend para capturar detalles de cada solicitud, como el método, la ruta, el tiempo de respuesta y el código de estado.

Una vez implementada la funcionalidad, se realizaron pruebas locales para asegurar su correcto funcionamiento y se añadieron pruebas unitarias para verificar que el sistema de logs no afectara otras partes del código. Al confirmar que todo funcionaba correctamente, se realizaron los commits y se abrió un Pull Request. GitHub Actions ejecutó automáticamente los workflows definidos: las pruebas unitarias validaron la funcionalidad, ESLint analizó el código y Docker preparó el contenedor para su despliegue. Tras la revisión y aprobación del PR, el cambio se integró a develop y el pipeline de entrega continua desplegó automáticamente la nueva versión del sistema en un entorno de pruebas.

Este flujo de trabajo, desde la planificación hasta el despliegue automatizado, refleja cómo se ha optimizado el proceso de desarrollo del proyecto Montaito-Hub. Gracias a la integración de herramientas como GitHub Actions y Docker, se logró una automatización completa del ciclo de vida del desarrollo, permitiendo que cada cambio se implementara de forma rápida, segura y controlada. Además, el uso de pruebas automatizadas y análisis de calidad garantizó que las funcionalidades entregadas cumplieran con los estándares definidos y no introdujeran errores.

En conclusión, el proceso de desarrollo del proyecto ha sido eficiente y estructurado, combinando metodologías ágiles, herramientas modernas y flujos de trabajo automatizados. Cada cambio propuesto en el sistema pasó por un ciclo riguroso de planificación, desarrollo, pruebas y despliegue, asegurando su calidad y estabilidad. Esta estrategia no solo permitió cumplir con los objetivos planteados, sino que también preparó el sistema para futuras evoluciones y mejoras, consolidándolo como una herramienta robusta, escalable y alineada con las mejores prácticas del desarrollo de software moderno.
### Entorno de Desarrollo
El entorno de desarrollo configurado para el proyecto Montaito-Hub ha sido diseñado para garantizar la eficiencia, la consistencia y la colaboración entre los miembros del equipo. Se trabajó con herramientas modernas y tecnologías actuales que facilitan tanto el desarrollo individual como el trabajo en equipo, permitiendo un flujo de trabajo ágil y automatizado. Dado que los miembros del equipo utilizaron diferentes sistemas operativos, como Windows 10/11, Linux Ubuntu 22.04 y macOS Monterey, se optó por un entorno basado en Docker para asegurar que el sistema funcionara de manera consistente en cualquier entorno local o de producción.

Como herramienta principal para el desarrollo del código, se utilizó Visual Studio Code, un editor ligero y altamente personalizable. Cada miembro configuró extensiones comunes como ESLint para garantizar la calidad del código, Prettier para el formateo automático y GitLens para el control visual de versiones. Otros miembros optaron por entornos integrados como PyCharm o IntelliJ IDEA para trabajar en la parte del backend, especialmente en scripts y configuraciones adicionales escritas en Python.

En cuanto a las tecnologías principales, el backend del sistema fue desarrollado utilizando Node.js en su versión 18.17.0, con el framework Express para crear una API RESTful modular y eficiente. Este entorno permitió implementar rutas, lógica de negocio y middleware personalizados que manejan funcionalidades como validaciones de datos, registro de errores y control de acceso. Para el frontend, se utilizó React.js en su versión 18.2.0, estructurando la aplicación en componentes reutilizables y conectando la interfaz de usuario con la API backend a través de solicitudes HTTP. React se utilizó con npm como gestor de paquetes, que facilitó la instalación de bibliotecas y herramientas necesarias para el proyecto.

El control de versiones se gestionó a través de Git y GitHub, utilizando un flujo de trabajo organizado que garantizaba la estabilidad del código y facilitaba la colaboración. La rama principal, main, se mantuvo como referencia para el código en producción, mientras que develop sirvió como rama de integración donde se fusionaban los cambios aprobados. Cada miembro del equipo trabajaba en ramas individuales específicas para cada funcionalidad o corrección de errores, asegurando un desarrollo paralelo sin conflictos. Al realizar cambios, estos pasaban por una revisión en forma de Pull Requests, donde se ejecutaban workflows automatizados configurados en GitHub Actions.

Una parte fundamental del entorno fue la implementación de Docker y Docker Compose, lo que permitió contenerizar tanto el backend como el frontend, junto con cualquier subsistema adicional necesario. Al utilizar Docker, se eliminó la dependencia de configuraciones específicas del sistema operativo, asegurando que el sistema funcionara de manera idéntica en cualquier entorno. Los miembros del equipo podían levantar el sistema completo con un solo comando, lo cual simplificaba significativamente la instalación y ejecución local del proyecto.

Para instalar y ejecutar el sistema, se siguieron los siguientes pasos. En primer lugar, se clonó el repositorio del proyecto utilizando el comando git clone, accediendo al directorio del proyecto con cd montaito-hub. A continuación, fue necesario instalar las dependencias tanto para el backend como para el frontend. En la carpeta del backend, se ejecutó npm install, lo que permitió instalar todos los paquetes requeridos para el funcionamiento del servidor. Lo mismo se realizó en el frontend, ejecutando nuevamente npm install en su directorio correspondiente. Además, se configuraron archivos de entorno utilizando ejemplos predefinidos en el repositorio, como .env.local.example, donde se especificaron variables como puertos, rutas y claves necesarias para ejecutar la aplicación.

Una vez configurado el entorno, el sistema podía ejecutarse localmente utilizando Node.js. Para iniciar el servidor backend, se utilizó el comando npm start dentro de la carpeta correspondiente, lo que levantaba el servidor en el puerto 5000. Simultáneamente, el frontend se iniciaba con el mismo comando, npm start, ejecutándose por defecto en el puerto 3000. Esto permitía a los desarrolladores interactuar con la aplicación completa en sus entornos locales y realizar pruebas funcionales antes de subir los cambios al repositorio.

El uso de Docker simplificó aún más este proceso. Al contar con archivos de configuración Dockerfile y docker-compose.yml, los desarrolladores solo necesitaban instalar Docker Desktop o Docker en sus sistemas. Con el comando docker-compose up --build, el sistema completo, incluido backend, frontend y bases de datos necesarias, se levantaba automáticamente en contenedores individuales. El frontend quedaba accesible en el puerto 3000, mientras que el backend funcionaba en el puerto 5000, garantizando la independencia entre las distintas partes del sistema y facilitando las pruebas en entornos controlados.

En términos de pruebas y calidad del código, el entorno incluyó herramientas específicas que se integraron en el flujo de desarrollo. Se utilizaron Jest y Pytest para realizar pruebas unitarias y de integración en el frontend y backend, respectivamente. Estas pruebas podían ejecutarse manualmente en el entorno local o automáticamente como parte de los flujos de trabajo en GitHub Actions. Para el análisis estático del código, se implementaron ESLint y Flake8, que permitieron detectar errores, inconsistencias y problemas de estilo, garantizando que el código del equipo cumpliera con los estándares establecidos.

Los diferentes entornos locales utilizados por los miembros del equipo también se sincronizaron con herramientas adicionales. Por ejemplo, los desarrolladores que trabajaban en Windows utilizaron WSL2 (Subsistema de Windows para Linux) para ejecutar comandos nativos de Linux y garantizar la compatibilidad con Docker. Aquellos que usaban macOS o Linux Ubuntu pudieron aprovechar directamente las configuraciones de contenedores y comandos de terminal sin complicaciones adicionales. Estas adaptaciones permitieron que el equipo trabajara sin importar las diferencias en los sistemas operativos.

En resumen, el entorno de desarrollo del proyecto Montaito-Hub fue diseñado para ser consistente, portable y eficiente. La combinación de herramientas como Node.js, React, Docker y GitHub Actions, junto con configuraciones estándar compartidas, permitió que el sistema pudiera ejecutarse y desarrollarse de manera colaborativa en cualquier entorno local. Esto aseguró que cada miembro del equipo pudiera contribuir sin fricciones al proyecto, manteniendo un flujo de trabajo estable, automatizado y alineado con las mejores prácticas del desarrollo moderno.
### Ejercicio de Propuesta de Cambio

### Conclusiones