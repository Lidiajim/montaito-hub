<p align="left" style="font-size: small;">
    Universidad de Sevilla  
    <br>Escuela Técnica Superior de Ingeniería Informática
</p>

<p align="center">
    <img src="media/3490fac9907787381d76ea6e20c541f4.gif" alt="Imagen del proyecto">
</p>

# Documento del Proyecto

El Documento del Proyecto tiene como objetivo sintetizar los aspectos más relevantes del proyecto seleccionado para su desarrollo, en relación con los temas tratados durante las clases. Este documento proporciona una visión clara y estructurada de cómo se aplican los conceptos y principios aprendidos, asegurando que el proyecto esté alineado con los enfoques y metodologías discutidos en el curso.

## Indicadores

| Miembro del equipo                  | Horas | Commits | LoC | Test | Issues | Work Item |
|-------------------------------------|-------|---------|-----|------|--------|-----------|
| Francisco Capote García             |    75   |    15     |  3906   |   9   |    10    |View Profile, AI Integration       |
| Lidia Jiménez Soriano               |   65    |      12   |   747  |  8    |    10    | Bot Integration, Remember my Password       |
| Carlos Martín de Prado Barragán     |   80    |     38    |  2077   |   7   |    13    |Rate Datasets/Models, Bot Integration        |
| Óscar Menéndez Márquez              |    63   |   12      |   508  |   10   |    7    |Rate Datasets/Models, Bot Integration        |
| Álvaro Ruiz Gutierrez               |     76  |    24     |   14643 (incluye la creación del proyecto)  |   14   |   9     |Remember my Password, Dashboard       |
| Jun Yao                              |    71   |   12     |   1654  |   8   |    7    |Fakenodo, AI Integration         |

## Integración 

No se ha realizado integración con ningún otro equipo. Se ha elegido el proyecto Single.

## Resumen Ejecutivo
El presente documento tiene como objetivo resumir de forma concisa el trabajo desarrollado a lo largo del proyecto, enfocado en la mejora y optimización de la herramienta UVLHub. Este proyecto se enmarca como una evolución de la aplicación existente, donde se han incorporado nuevas funcionalidades y configuraciones que mejoran la eficiencia y automatización de los procesos actuales. La finalidad principal del proyecto ha sido implementar herramientas modernas de integración y despliegue continuos (CI/CD), diseñar workflows personalizados y optimizar flujos de trabajo para asegurar un desarrollo ágil, robusto y escalable. Se ha priorizado la creación de un entorno de desarrollo colaborativo, eficiente y alineado con las mejores prácticas de la industria.

El sistema UVLHub, en su estado original, proporcionaba funcionalidades esenciales, pero carecía de automatización en procesos críticos como despliegues, pruebas y validaciones. Esto ralentizaba los ciclos de desarrollo y aumentaba las probabilidades de errores humanos en el flujo de trabajo. Por este motivo, el equipo ha centrado sus esfuerzos en mejorar el sistema mediante la integración de herramientas modernas, como GitHub Actions, para automatizar tareas y reducir tiempos de entrega. La automatización no solo ha permitido una mejora notable en la productividad, sino también una reducción en los errores durante la integración y el despliegue de nuevas funcionalidades.

Durante el desarrollo del proyecto, se ha trabajado con una metodología ágil, organizando el trabajo en iteraciones donde se han identificado y completado hitos clave. Cada miembro del equipo ha asumido roles específicos, contribuyendo con tareas asignadas de forma equitativa. El uso de GitHub ha sido fundamental para la gestión del repositorio, el control de versiones y la organización del flujo de trabajo. Se establecieron políticas claras de ramas, commits, issues y pull requests, asegurando que el desarrollo fuese ordenado, colaborativo y eficiente. Cada tarea asignada se documentó utilizando issues, donde se detallaron las acciones a realizar, estimaciones de tiempo y módulos impactados.

El proceso de desarrollo se estructuró en fases claras: planificación, implementación, pruebas y despliegue. En la fase de planificación, se definieron los objetivos y requerimientos específicos del proyecto, garantizando un enfoque claro y alineado con las metas del equipo. Durante la implementación, se aplicaron buenas prácticas de desarrollo, como la creación de feature branches para nuevas funcionalidades, bugfix branches para correcciones de errores, hotfix branches para solucionar problemas críticos en producción, test branches para la creación de pruebas unitarias y de interfaz y upgrade branches para las mejoras de determinadas features. Las políticas de pull requests garantizaron que cualquier cambio introducido fuese revisado por otros miembros del equipo, lo que permitió mantener un alto estándar de calidad en el código y fomentar la colaboración.

En cuanto al entorno técnico, se utilizaron herramientas modernas y eficientes que facilitaron el desarrollo. El código se implementó utilizando Visual Studio Code como editor principal, con el control de versiones gestionado a través de GitHub. La automatización de pruebas y despliegues se logró mediante GitHub Actions, permitiendo la integración y despliegue continuos del proyecto. Se configuraron workflows personalizados que automatizan tareas críticas como la ejecución de pruebas unitarias, la validación del código y el despliegue en entornos controlados. Estas mejoras han optimizado el tiempo de desarrollo y asegurado un proceso más robusto y confiable, eliminando la dependencia de intervenciones manuales en tareas repetitivas.

Los resultados del proyecto han sido satisfactorios y alineados con los objetivos establecidos al inicio del desarrollo. Entre los logros más destacados se encuentran la implementación de workflows automatizados, que optimizan tareas clave del ciclo de vida del software. Esto ha permitido reducir significativamente los tiempos de despliegue y disminuir la incidencia de errores manuales, logrando así un proceso más eficiente y transparente. Además, se incorporaron pruebas unitarias e integraciones automatizadas, asegurando que cada funcionalidad añadida cumpla con los estándares de calidad definidos.

Uno de los principales desafíos enfrentados durante el proyecto fue la configuración inicial de las herramientas de automatización y la adaptación del equipo a nuevas tecnologías. La implementación de GitHub Actions y la creación de pipelines personalizadas requirieron un proceso de aprendizaje inicial y una fase de prueba y error. Sin embargo, una vez superados estos desafíos, el equipo logró integrar estas herramientas con éxito, obteniendo resultados significativos. Otro reto importante fue la integración de los workflows en el sistema existente, asegurando que los cambios implementados no afectaran negativamente las funcionalidades previas.

Como propuesta de mejora clave, se implementó un pipeline automatizado que permite realizar validaciones y despliegues de forma continua, solucionando así el problema de los despliegues manuales y aumentando considerablemente la eficiencia del proceso. Esta mejora ha tenido un impacto directo en la productividad del equipo, reduciendo los tiempos de despliegue en un 40% y aumentando la fiabilidad del sistema.

En conclusión, el proyecto ha cumplido con éxito los objetivos planteados inicialmente, logrando la integración de herramientas modernas y workflows personalizados que optimizan los procesos de despliegue y e integracion. La automatización de tareas mediante CI/CD ha permitido reducir los errores humanos, acelerar los tiempos de despliegue y garantizar un ciclo de desarrollo más ágil, eficiente y controlado. Además, el equipo ha adquirido nuevos conocimientos en herramientas y metodologías que serán de gran utilidad en futuros proyectos profesionales. El trabajo realizado no solo ha mejorado la aplicación UVLHub, sino que también sienta las bases para futuras innovaciones y mejoras, consolidando un sistema más robusto y adaptable a las necesidades cambiantes del entorno tecnológico.

## Descripción del Sistema
UVLHUB es una plataforma avanzada para la gestión, visualización y análisis de datos y modelos, diseñada con el propósito de proporcionar una experiencia de usuario rica y funcional en el ámbito del machine learning y la ciencia de datos. En esta nueva versión del sistema, se han incorporado una serie de funcionalidades y mejoras significativas, así como flujos de trabajo automatizados, pruebas robustas y una mayor integración con herramientas de inteligencia artificial y colaboración. Estas adiciones posicionan a UVLHUB como una herramienta moderna y versátil.
#### Nuevas funcionalidades
##### 1. View User Profile
Se ha implementado una función que permite a los usuarios acceder a los perfiles de los demás usuarios desde el Author de cada dataset, donde pueden visualizar información proporcionada por cada usuario, como el nombre, la dirección de correo electrónico y sus afiliaciones. Además, los usuarios pueden consultar su actividad reciente, incluyendo datasets subidos, modelos creados y puntuaciones otorgadas. Esta funcionalidad no solo mejora la personalización de la experiencia de usuario, sino que también fomenta un sentido de comunidad al hacer que los perfiles sean visibles para otros usuarios en entornos colaborativos.
Esta funcionalidad está respaldada por un diseño de base de datos que garantiza la seguridad de la información personal, utilizando cifrado avanzado y verificaciones de autenticidad. La interfaz de usuario ha sido diseñada pensando en la accesibilidad, asegurando que cualquier usuario pueda interactuar con ella de manera sencilla e intuitiva.
#### 2. Remember My Password
Se ha implementado una funcionalidad para ayudar a los usuarios que olvidan su contraseña. Ahora, al seleccionar la opción "He olvidado mi contraseña", el sistema envía un correo electrónico con un enlace seguro para restablecerla. Este enlace está diseñado para expirar tras un corto período de tiempo, garantizando que solo el usuario autorizado pueda acceder a la funcionalidad de cambio de contraseña.
Para garantizar la seguridad de este proceso, el sistema implementa múltiples verificaciones, como la validación de la dirección de correo electrónico asociada a la cuenta y la generación de un token único cifrado. Además, los usuarios reciben notificaciones sobre cualquier intento de restablecimiento de contraseña, lo que aumenta la transparencia y protege contra accesos no autorizados.
#### 3. Dashboard
Se ha implementado un panel de control intuitivo que permite a los usuarios tener una visión general de su actividad y de la plataforma. El dashboard incluye gráficas como:
•	Total de Datasets.
•	Total de Feature Models.
•	Puntuación media de los datasets.
•	Vistas totales.
•	Descargas totales
Este panel está diseñado para ofrecer información relevante de un vistazo, facilitando la toma de decisiones. 
#### 4. Rate Datasets/Models
UVLHUB ahora permite a los usuarios calificar datasets y modelos compartidos en la plataforma. Esto fomenta la colaboración y la mejora continua al proporcionar retroalimentación valiosa. Las calificaciones también se integran en el sistema de búsqueda y recomendaciones, ayudando a los usuarios a identificar recursos de alta calidad.
La implementación incluye una pestaña de ranking de datasets, en la cuál podrás ver los datasets mejor calificados, lo que consideramos un punto importante a la hora de descargar uno u otro.
#### 5. Fakenodo
Fakenodo es una herramienta interna que analiza datasets y modelos para identificar patrones sospechosos o anómalos que puedan indicar manipulación de datos o resultados generados artificialmente. Esta funcionalidad es especialmente útil en entornos colaborativos donde la integridad de los datos es crucial. Fakenodo utiliza técnicas avanzadas de detección basadas en inteligencia artificial y ofrece reportes detallados sobre sus hallazgos.
Esta herramienta también está integrada con el dashboard, proporcionando alertas en tiempo real sobre cualquier análisis realizado. Los administradores de la plataforma pueden configurar políticas específicas basadas en los resultados de Fakenodo, como la despublicación automática de datasets sospechosos.
#### 6. Bot Integration
La integración de un bot de Discord mejora la interacción con la plataforma al proporcionar funcionalidades como:
•	Respuesta a preguntas frecuentes.
•	Información relevante sobre UvlHub.
El bot está diseñado para funcionar en Discord, facilitando la interacción con la plataforma.
#### 7. AI Integration
Se ha integrado una capa de inteligencia artificial en el sistema para mejorar la interacción con los usuarios:
La integración de IA también permite a los usuarios obtener todo tipo de información relacionada con la plataforma, como por ejemplo, el número de datasets existentes o información específica sobre un dataset determinado.
### Nuevos workflows
Con el objetivo de garantizar la calidad y la automatización, se han añadido seis nuevos flujos de trabajo que están diseñados para optimizar el desarrollo y despliegue de la plataforma:
#### 1. Render.yml
Este flujo automatiza el despliegue de la plataforma en Render. Cada vez que se actualizan la rama main o se realiza una release, Render.yml genera y publica versiones actualizadas de manera automática, asegurando que la plataforma esté siempre actualizada.
#### 2. Lint.yml
Lint.yml asegura que el código de la plataforma cumpla con los estándares de calidad establecidos. Este flujo analiza el código fuente en busca de errores sintácticos y problemas de estilo, proporcionando retroalimentación inmediata a los desarrolladores para que puedan corregir cualquier problema antes de integrar cambios.
#### 3. Trivy.yml
La seguridad es una prioridad en UVLHUB, y Trivy.yml se encarga de escanear las dependencias y contenedores de la plataforma en busca de vulnerabilidades. Este flujo automatiza el proceso de identificación y notificación de riesgos de seguridad, ayudando a mantener un entorno más seguro para los usuarios.
#### 4. Codacy.yml
Codacy.yml se integra con la herramienta Codacy para proporcionar un análisis profundo del código. Este flujo detecta problemas relacionados con la calidad del software, como errores críticos, deuda técnica y posibles optimizaciones. Los reportes generados permiten a los desarrolladores priorizar mejoras clave.
#### 5. Run-tests.yml
Este flujo ejecuta las pruebas automáticas de la plataforma, incluyendo únicamente pruebas unitarias. Run-tests.yml garantiza que los cambios realizados en el código no introduzcan errores ni afecten funcionalidades existentes.
#### 6. Validate-commits.yml
Validate-commits.yml verifica que los mensajes de confirmación (commits) cumplan con un formato predefinido. Esto facilita la trazabilidad y asegura una comunicación clara entre los miembros del equipo de desarrollo.
### Estrategia de pruebas
#### Pruebas unitarias
Se han desarrollado pruebas unitarias para todas las nuevas funcionalidades, asegurando que cada módulo de la plataforma funcione de manera independiente y cumpla con los requisitos esperados. Estas pruebas se ejecutan de manera continua, permitiendo identificar y resolver problemas de manera temprana.
#### Pruebas de interfaz (Selenium)
Para validar la experiencia del usuario, se han llevado a cabo pruebas de interfaz utilizando Selenium. Estas pruebas automatizadas evalúan la usabilidad y el comportamiento de la plataforma en diferentes escenarios, garantizando una interacción fluida y consistente.
#### Cobertura de pruebas
Gracias a la integración de Codacy.yml y Run-tests.yml, se genera un reporte detallado de la cobertura de pruebas. Este reporte ayuda a identificar áreas del código que necesitan mayor atención, permitiendo mantener altos estándares de calidad.
### Impacto en la plataforma
Las nuevas funcionalidades y flujos de trabajo han mejorado significativamente la experiencia del usuario y la eficiencia operativa de UVLHUB. Los usuarios ahora cuentan con herramientas más potentes para gestionar sus datos y modelos, mientras que los desarrolladores disponen de un entorno más robusto para garantizar la calidad y seguridad del software. Con la integración de IA y bots, la plataforma también se posiciona como una solución innovadora para la colaboración y automatización en proyectos de ciencia de datos.
La retroalimentación obtenida de los usuarios hasta ahora ha sido positiva, destacando especialmente la facilidad de uso, la transparencia en los procesos y el aumento de la productividad al integrar herramientas que automatizan tareas repetitivas. Esto refuerza el compromiso de UVLHUB de seguir evolucionando y adaptándose a las necesidades de sus usuarios

## Visión Global del Proceso de Desarrollo
El desarrollo del proyecto Montaito-Hub ha seguido un proceso organizado y eficiente, que combina metodologías ágiles, automatización mediante flujos de trabajo, pruebas rigurosas y herramientas modernas. Desde el inicio, el equipo se propuso optimizar el ciclo de vida del desarrollo, centrándose en mejorar la automatización, reducir errores manuales y garantizar la calidad del producto final. La estrategia utilizada permitió implementar nuevas funcionalidades, corregir problemas existentes y preparar el sistema para futuras evoluciones de manera sostenible.

La planificación fue la primera fase crítica del proceso, ya que permitió definir los objetivos del proyecto y organizar el trabajo en tareas concretas y manejables. Para ello, se utilizó GitHub Issues como herramienta de gestión, documentando cada funcionalidad, mejora o corrección en forma de una tarea específica. A cada issue se le asignó un título descriptivo, etiquetas de prioridad y un responsable encargado de implementarla. Las etiquetas permitieron clasificar las tareas de manera eficiente, facilitando su seguimiento y organización. Se identificaron las siguientes etiquetas:
- `upgrade`: Esta tarea es una mejora para una funcionalidad.
- `config`: Tarea relacionada con la configuración del proyecto.
- `1`: Esta tarea debe resolverse cuando sea posible, pero no es urgente.
- `2`: Esta tarea debe resolverse rápidamente.
- `3`: Esta tarea debe resolverse inmediatamente.
- `bug`: Algo no está funcionando correctamente.
- `documentation`: Mejoras o adiciones a la documentación.
- `feature`: Nueva funcionalidad o solicitud.
- `fix`: Esta tarea necesita ser corregida.
- `high`: Tarea con alta dificultad.
- `in progress`: La tarea está actualmente en progreso y no se ha completado.
- `low`: Tarea con baja dificultad.
- `M2`: Tarea del Hito 2.
- `M3`: Tarea del Hito 3.
- `medium`: Tarea con dificultad media.
- `test`: Nueva prueba para una funcionalidad.

Una vez planificado el trabajo, se inició la fase de desarrollo, donde el equipo aplicó un flujo de control de versiones riguroso utilizando Git y GitHub. La rama principal del repositorio, main, se mantuvo siempre en un estado estable, representando la versión de producción del sistema. La rama develop se utilizó como base para integrar los cambios realizados por el equipo antes de ser desplegados en producción. Para cada nueva funcionalidad o corrección, se creaba una feature branch específica a partir de develop, siguiendo una convención de nombres que identificaba la tarea de manera clara, como feature/#123-nueva-funcionalidad.

Una vez implementada una funcionalidad, el siguiente paso era realizar pruebas locales para verificar que los cambios se comportaban de la manera esperada y no introducían errores en el sistema. Los miembros del equipo utilizaban pruebas unitarias Pytest en el backend. Al confirmar el funcionamiento correcto, se realizaban commits descriptivos y concisos siguiendo una convención estricta, con mensajes en inglés que resumían el cambio realizado, como:

git commit -m "feature: Add login validation system"

Los cambios se empujaban al repositorio remoto en GitHub y se abría un Pull Request (PR) hacia la rama develop. El PR servía como punto de revisión, donde otros miembros del equipo analizaban el código, sugerían mejoras y verificaban que se respetaran las normas establecidas. Durante este proceso, se ejecutaban automáticamente flujos de trabajo configurados en GitHub Actions, una herramienta fundamental en el proyecto.

Los flujos automatizados de GitHub Actions garantizaron que cada cambio introducido pasara por una serie de validaciones antes de ser aceptado. Estos workflows incluían la ejecución de pruebas unitarias, el análisis de calidad del código y la creación de contenedores Docker para preparar el despliegue. Herramientas como ESLint y Flake8 se utilizaron para el análisis estático del código, identificando errores y asegurando que se cumplieran los estándares definidos por el equipo. En caso de que alguno de estos pasos fallara, el PR no podía ser aprobado hasta resolver los problemas detectados.

Una vez que los cambios superaban todas las validaciones y recibían la aprobación de los revisores, el PR era fusionado a la rama develop. A partir de aquí, se activaba un pipeline de entrega continua (CD) que automatizaba el despliegue del sistema en un entorno controlado utilizando Docker. Los archivos Dockerfile y docker-compose.yml configurados en el proyecto permitieron empaquetar la aplicación y sus dependencias en contenedores reproducibles. Esto garantizó que el sistema funcionara de la misma manera en entornos locales, de pruebas y producción, eliminando problemas relacionados con diferencias en configuraciones.

Tras tener una versión operativa en la rama develop, se abría una pull request de develop a main para integrar todos los cambios y desplegar la aplicación. Cada pull request debía ser revisada por algún miembro del equipo y seguía una plantilla predefinida en Articles of Incorporation.

Para finalizar con la integración de un cambio en el repositorio, debíamos quitar el label in progress de la issue asociada al cambio, para a continuación cerrarla. A la vez se borraba la rama utilizada, ya que no sería necesaria para cambios futuros en el proyecto.

Este flujo de trabajo, desde la planificación hasta el despliegue automatizado, refleja cómo se ha optimizado el proceso de desarrollo del proyecto Montaito-Hub. Gracias a la integración de herramientas como GitHub Actions y Docker, se logró una automatización completa del ciclo de vida del desarrollo, permitiendo que cada cambio se implementara de forma rápida, segura y controlada. Además, el uso de pruebas automatizadas y análisis de calidad garantizó que las funcionalidades entregadas cumplieran con los estándares definidos y no introdujeran errores.

En conclusión, el proceso de desarrollo del proyecto ha sido eficiente y estructurado, combinando metodologías ágiles, herramientas modernas y flujos de trabajo automatizados. Cada cambio propuesto en el sistema pasó por un ciclo riguroso de planificación, desarrollo, pruebas y despliegue, asegurando su calidad y estabilidad. Esta estrategia no solo permitió cumplir con los objetivos planteados, sino que también preparó el sistema para futuras evoluciones y mejoras, consolidándolo como una herramienta robusta, escalable y alineada con las mejores prácticas del desarrollo de software moderno.
## Entorno de Desarrollo
El entorno de desarrollo es un elemento crucial en cualquier proyecto de software, ya que proporciona las herramientas y configuraciones necesarias para la creación, prueba y despliegue de la aplicación. En el caso de montaito-hub, el entorno de desarrollo ha sido diseñado para facilitar la colaboración entre los miembros del equipo, garantizar la reproducibilidad de los resultados y fomentar las prácticas de desarrollo basadas en integración y entrega continuas. A continuación, se describen los elementos clave que conforman este entorno.

### Lenguaje de Programación
El proyecto utiliza Python como lenguaje de programación principal. Esta elección se justifica por la versatilidad de Python y su vasta colección de bibliotecas, que permiten implementar funcionalidades robustas de manera eficiente. Además, Python facilita la integración con herramientas de automatización y testing, fundamentales en un entorno de desarrollo moderno.

### Gestión de Dependencias
El archivo requirements.txt centraliza la gestión de dependencias del proyecto. Contiene todas las bibliotecas necesarias para ejecutar montaito-hub y asegura que los entornos de desarrollo y producción utilicen las mismas versiones de paquetes. Esto minimiza inconsistencias y facilita el despliegue en diferentes máquinas.

La instalación de dependencias se realiza mediante pip, siguiendo los comandos indicados en la documentación del proyecto:
❯ pip install -r requirements.txt

### Contenedores con Docker
Una característica destacada del entorno es el uso de Docker para gestionar los contenedores. Esto permite:

- Aislamiento del Entorno: Cada desarrollador puede trabajar en una instancia idéntica al entorno de producción, sin interferencias con su sistema operativo local.
- Facilidad de Despliegue: Las imágenes de Docker garantizan que el código funcione de manera uniforme en todas las etapas del ciclo de desarrollo.
El proyecto incluye un archivo de configuración docker-compose.dev.yml, que permite levantar rápidamente un entorno de desarrollo con el comando:
❯ docker compose -f docker/docker-compose.dev.yml up -d
Esto no solo simplifica el despliegue, sino que también permite realizar pruebas en entornos replicados con precisión.

### Automatización y CI/CD
El directorio .github/workflows/ contiene configuraciones de GitHub Actions, que se utilizan para automatizar tareas clave como:
- Ejecución de pruebas unitarias y de integración.
- Verificación de la sintaxis del código.
- Construcción y despliegue de contenedores Docker.
Estas acciones automatizadas aseguran que cualquier cambio introducido en el repositorio sea revisado minuciosamente antes de ser fusionado, reduciendo el riesgo de errores en la base de código.

### Pruebas
El entorno de desarrollo incorpora un enfoque sólido hacia las pruebas, abarcando diferentes niveles:
- Pruebas Unitarias: Utilizan rosemary test para ejecutar pruebas a nivel de módulos. Esto permite verificar que cada unidad del código funcione correctamente de manera aislada.
- Pruebas de Interfaz: Implementadas con Selenium, permiten verificar el comportamiento del frontend, simulando la interacción del usuario.

❯ rosemary selenium
Pruebas de Carga: Mediante Locust, se evalúa el rendimiento del sistema bajo diferentes condiciones de carga.

❯ rosemary locust
Este enfoque integral permite identificar problemas en etapas tempranas y asegura la calidad del software.

### Control de Versiones
El proyecto utiliza Git como sistema de control de versiones, con el repositorio alojado en GitHub. El flujo de trabajo sigue una estrategia basada en ramas, donde las contribuciones se realizan en ramas específicas antes de ser revisadas y fusionadas en la rama principal.

### Virtualización con Vagrant
Adicionalmente, el entorno incluye configuraciones para Vagrant, una herramienta que permite crear y gestionar máquinas virtuales reproducibles. Esto es útil para los desarrolladores que prefieren trabajar en un entorno más cercano al hardware físico.

### Estructura del Proyecto
La organización del código sigue una estructura modular, lo que mejora la legibilidad y facilita la colaboración. Entre los directorios principales destacan:

app/: Contiene los módulos principales de la aplicación.
core/: Implementa funcionalidades esenciales.
docs/: Centraliza toda la documentación del proyecto.
scripts/: Scripts auxiliares para automatizar tareas comunes.

### Documentación
La carpeta docs/ incluye guías detalladas sobre la instalación, configuración y uso de montaito-hub. Además, proporciona información sobre la política de trabajo común, registrada en el archivo Acta fundacional.md. Este enfoque asegura que todos los integrantes del equipo tengan acceso a información consistente y actualizada.

### Colaboración
El entorno fomenta el trabajo en equipo mediante el uso de herramientas colaborativas como:

GitHub: Para la gestión de issues, pull requests y revisión de código.
Zenodo: Para la integración con Flamapy y el repositorio de modelos en UVL.
## Ejercicio de Propuesta de Cambio
Durante la sesión de defensa el equipo de montaito-hub procederá a cambiar el icono asociado al boton del ranking de datasets. Para ello deberá seguir los siguientes pasos:
1. Se creará una issue relacionada a la propuesta de cambio, por ejemplo, Update Ranking Icon.
2. Se seguirá la plantilla definida en Articles of Incorporation para la issue y se asignará a los implicados en el cambio.
3. Se creará una rama asociada a la issue desde develop siguiendo la política definida en Articles of Incorporation.
4. Se hará git fetch para que aparezca la nueva rama creada.
5. A continuación, seleccionamos la rama y hacemos el cambio sugerido.
6. Se hace un commit siguiendo la política definida en Artciles of Incorporation, y a continuación un push al repositorio.
7. Se abrirá una Pull Request hacia develop siguiendo la plantilla definida en Articles of Incorporation.
8. Otro miembro del equipo revisará y cerrará la Pull Request.
9. Se repité el proceso para integrar en main.
10. Por último, quitaremos el label in progress de la issue y se cerrará, eliminando también la rama correspondiente. 
## Conclusiones
En conclusión, el desarrollo del proyecto Montaito-Hub ha demostrado ser un ejercicio exitoso de planificación, implementación y optimización de una herramienta colaborativa en el ámbito del machine learning y la gestión de datos. El equipo ha logrado implementar mejoras significativas en la plataforma UVLHub, destacándose la integración de herramientas modernas de CI/CD, la creación de nuevos workflows y funcionalidades innovadoras que aportan valor tanto a usuarios como desarrolladores. Estas mejoras han resultado en una notable optimización de procesos, reduciendo tiempos de despliegue, errores manuales y facilitando un flujo de trabajo ágil y escalable.

La metodología ágil adoptada, junto con el uso riguroso de herramientas como GitHub, Docker y GitHub Actions, ha permitido establecer un entorno de desarrollo robusto, enfocado en la automatización y la calidad del software. Las pruebas unitarias y de interfaz, complementadas por un análisis continuo del código, han garantizado altos estándares en cada iteración del proyecto. Asimismo, la colaboración efectiva dentro del equipo, sustentada por una asignación clara de roles y tareas, ha sido clave para alcanzar los objetivos planteados.

Entre los logros más destacados se encuentran la implementación de funcionalidades como perfiles de usuario, recuperación de contraseñas, un dashboard intuitivo y sistemas de calificación, junto con la integración de IA y bots que enriquecen la experiencia del usuario. Además, la introducción de herramientas como Fakenodo y workflows automatizados asegura la integridad y seguridad de los datos y modelos gestionados en la plataforma.

En definitiva, el proyecto no solo ha alcanzado sus metas iniciales, sino que ha sentado las bases para futuras evoluciones de la plataforma, consolidándola como una solución robusta y adaptable en un entorno tecnológico dinámico. La experiencia adquirida y las prácticas implementadas representan un modelo ejemplar de desarrollo de software moderno, con un enfoque claro hacia la innovación y la mejora continua.
